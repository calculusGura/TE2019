q()
1+1
q()
setwd("/home/buzzsongs/TE2019"); ##chrome os
rm(list = ls());
getwd()
source("./setEnvirionment.R");
setwd("/home/buzzsongs/TE2019")
setwd("/home/buzzsongs/TE2019/")
setwd("./home/buzzsongs/TE2019/")
getwd*
csvData1 <- read.csv("./productData/compDPstructure.csv");
setwd("./TE2019")
setwd("/home/buzzsongs/te2019"); ##chrome os
rm(list = ls());
source("./setEnvirionment.R");
source("./setEnvirionment.R");
source("./dataClasses.R");
csvData2 <- read.csv("./productData/constDP.csv");
csvData3 <- read.csv("./productData/taskDP.csv");
#csvData4 <- read.csv("./productData/taskTask.csv");
csvData5 <- read.csv("./productData/statusWeight.csv");
source("./generateModel.R");
productData <- generateCompDPModel(csvData1);
csvData1 <- read.csv("./productData/compDPstructure.csv");
productData <- generateCompDPModel(csvData1);
productData <- generateConstDPModel(csvData2, productData);
productData <- generateTaskDPModel(csvData3, productData);
#productData <- generateTaskTaskModel(csvData4, productData);
productData <- generateWeightModel(csvData5, productData);
source("./networkView.R");
showProductNetwork(productData);
source("./explorePropagationPath.R");
path <- exploringPropagationPath(c("D1"), productData);
path
path
source("./pathEvaluation.R");
path <- evaluatePathRisk(path, productData);
(path@constDPMatrix)
solutionArea <- colSums(path@constDPMatrix)/colSums(productData@constDPMatrix);
solutionArea
colSums(path@constDPMatrix)/
colSums(path@constDPMatrix)
colSums(productData@constDPMatrix);
0/3
0/0
1.0
1/0
length(solutionArea)
subset(solutionArea, solutionArea=4);
subset(solutionArea, solutionArea >3);
solutionArea
solutionArea <- colSums(path@constDPMatrix)/colSums(productData@constDPMatrix);
solutionArea
subset(solutionArea, solutionArea < 1);
length(subset(solutionArea, solutionArea < 1))
source("./pathEvaluation.R");
path <- evaluatePathRisk(path, productData);
costData
productData@compDPMatrix[,]
costData <- merge(productData@compDPMatrix[,], productData@dpList[,],
by.x="row.names", by.y="row.names");
costData
productData@compStatusWeight
productData@dpList[,5] <- "D";
productData@dpList[1:6,5] <- "M";
productData@taskList[,4] <- "P"
productData@taskList[1:3,4] <- "F"
productData@taskList[4:5,4] <- "O"
productData@taskList[4:5,4] <- "O"
productData@taskList
source("./pathEvaluation.R");
path <- evaluatePathRisk(path, productData);
costData
rownames(tail(productData@compList,1))
row.names(costData) <- costData$Row.names;
row.names
costData$Row.names;
costData
costData <- merge(productData@compDPMatrix[,], productData@dpList[,],
by.x="row.names", by.y="row.names");
costData <- merge(costData, productData@compStatusWeight,
by.x="status", by.y="compStatus");
costData
firstIndex <- grep(rownames(head(productData@compList,1)), colnames(costData))[1];
lastIndex <- grep(rownames(tail(productData@compList,1)), colnames(costData));
lastIndex
row.names(costData) <- costData$Row.names;
costData
costData <- cbind(costData[c("type", "importance", "costSens", "status", "statusWeight")],
costData[firstIndex:lastIndex])
costData
baseCost <- productData@compList[,2];
baseCost
nrow(costData)
costData[,6:(6+lastIndex-firstIndex)] <- (costData[,6:(6+lastIndex-firstIndex)]
* costData[,"costSens"]
* costData[,"statusWeight"]);
costData
costRisk <- (colSums(costData[usedDPs,6:(6+lastIndex-firstIndex)])
/ colSums(costData[,6:(6+lastIndex-firstIndex)]));
costRisk
0/0
1/0
0/1
source("./pathEvaluation.R");
path <- evaluatePathRisk(path, productData);
deliveryData
taskDPMatrix[usedDPs,]
row.names(deliveryData) <- deliveryData$Row.names;
deliveryData <- deliveryData[c("name", "duration", "type", "taskStatus", "statusWeight", "usedRatio")];
deliveryData
producatData
productData
deliveryRisk
deliveryData
deliveryData[,"statusWeight"]
source("./pathEvaluation.R");
path <- evaluatePathRisk(path, productData);
source("./pathEvaluation.R");
path <- evaluatePathRisk(path, productData);
row.names(deliveryData) <- deliveryData$Row.names;
deliveryData <- deliveryData[c("name", "duration", "type", "taskStatus", "statusWeight", "usedRatio")];
#dequation of elivery evaluation
##statusWeight * taskDuration * DPs, then narrow down to used DPs
deliveryData
rm(list = ls());
#test case
test <- matrix(0, ncol=4, nrow= 100);
test <- as.data.frame(test);
test[,1] <- paste0("P",1:nrow(test));
test[,2] <- runif(100, min=0, max=100);
test[,3] <- runif(100, min=0, max=100);
test[,4] <- runif(100, min=0, max=100);
colnames(test) <- c("name", "quality", "cost", "delivery")
test2 <- matrix(0, ncol=4, nrow= 100);
test2 <- as.data.frame(test);
test2[,1] <- paste0("P",1:nrow(test));
test2[,2] <- runif(100, min=50, max=100);
test2[,3] <- runif(100, min=50, max=100);
test2[,4] <- runif(100, min=50, max=100);
colnames(test2) <- c("name", "quality", "cost", "delivery")
#scatter app
rv <- reactiveValues();
ui <- fluidPage(
plotOutput("plot1",
click = "plot_click",
hover = hoverOpts(id = "plot_hover", delayType = "throttle"),
dblclick = "plot_dblclick"),
tableOutput("plot_clicked_points1"))
server <- function(input, output, session){
output$plot1 <- renderPlot({
ggplot(data = test, aes(x = cost, y = delivery)) +
geom_point(aes(colour=quality), size=3, alpha=0.8) +
scale_colour_gradient(low = "red", high = "blue") +
scale_x_continuous(limits = c(0, NA)) +
scale_y_continuous(limits = c(0, NA))
}, width = "auto", height = "auto");
#show the plot data hovered
observeEvent(input$plot_hover,
{rv$selected_plot <- nearPoints(test, input$plot_hover, threshold = 4, maxpoints = 1)});
output$plot_clicked_points1 <- renderTable({rv$selected_plot});
#select the plot on where clicked
observeEvent(input$plot_dblclick,
{selected_plot <<- nearPoints(test, input$plot_dblclick, threshold = 4, maxpoints = 1)});
}
shinyApp(ui, server)
#test
p <- ggplot(data=test, aes(x=cost, y=delivery)) +
geom_point(aes(colour=quality), size=3, alpha=0.8) +
geom_point(data=test2, aes(colour=quality), size=3, alpha=0.8) +
scale_colour_gradient(low = "red", high = "blue") +
scale_x_continuous(limits = c(0, NA)) +
scale_y_continuous(limits = c(0, NA))
ggplotly(p)
